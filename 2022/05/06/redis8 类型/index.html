<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>redis8 类型 | walker</title><meta name="author" content="walker"><meta name="copyright" content="walker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="redis 类型 Strings Lists Sets Hashes Sorted sets Streams Geospecial(地理位置) HyperLogLog（基数统计） Bitmaps（位图） Bitfields（比特字段）  redis 如果 key 的值为空时，redis 会自动销毁该键，无需提前定义该键的值类型，但是如果设置了该值，却用了其他类型的操作去操作该键会报异常。 Stri">
<meta property="og:type" content="article">
<meta property="og:title" content="redis8 类型">
<meta property="og:url" content="http://example.com/2022/05/06/redis8%20%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="walker">
<meta property="og:description" content="redis 类型 Strings Lists Sets Hashes Sorted sets Streams Geospecial(地理位置) HyperLogLog（基数统计） Bitmaps（位图） Bitfields（比特字段）  redis 如果 key 的值为空时，redis 会自动销毁该键，无需提前定义该键的值类型，但是如果设置了该值，却用了其他类型的操作去操作该键会报异常。 Stri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-05-06T08:09:40.000Z">
<meta property="article:modified_time" content="2023-01-03T00:52:11.716Z">
<meta property="article:author" content="walker">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/05/06/redis8%20%E7%B1%BB%E5%9E%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis8 类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-03 08:52:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdwx.qlogo.cn/mmopen/vi_32/BsLUROthXHzaLGgAuYiapwa4htsNc0H2MQ8sGkVHVNqib7viaqwhXK6KDXayjQBpkPY0gleTCqAcEPL1kEwjP9S0Q/132" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">walker</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis8 类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-06T08:09:40.000Z" title="发表于 2022-05-06 16:09:40">2022-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-03T00:52:11.716Z" title="更新于 2023-01-03 08:52:11">2023-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis8 类型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="redis-类型"><a href="#redis-类型" class="headerlink" title="redis 类型"></a>redis 类型</h2><ol>
<li>Strings</li>
<li>Lists</li>
<li>Sets</li>
<li>Hashes</li>
<li>Sorted sets</li>
<li>Streams</li>
<li>Geospecial(地理位置)</li>
<li>HyperLogLog（基数统计）</li>
<li>Bitmaps（位图）</li>
<li>Bitfields（比特字段）</li>
</ol>
<p>redis 如果 key 的值为空时，redis 会自动销毁该键，无需提前定义该键的值类型，但是如果设置了该值，却用了其他类型的操作去操作该键会报异常。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>支持保存文本、序列化对象、二进制数组，允许进行计数器、位操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置值</span></span><br><span class="line"><span class="built_in">set</span> mykey somevalue</span><br><span class="line"><span class="comment">#获取值</span></span><br><span class="line">get mykey</span><br><span class="line"><span class="comment">#检测如果存在就不设置</span></span><br><span class="line"><span class="built_in">set</span> mykey newval nx</span><br><span class="line"><span class="comment">#强制设置</span></span><br><span class="line"><span class="built_in">set</span> mykey newval xx</span><br><span class="line"><span class="comment">#设置时指定过期时间</span></span><br><span class="line"><span class="built_in">set</span> request 1 ex 30 nx</span><br><span class="line"><span class="comment">#自增/自减 (incr/decr) 该操纵是原子的不会出现竞争情况，因为 redis 从设计上是单进程单线程</span></span><br><span class="line"><span class="built_in">set</span> counter 100</span><br><span class="line">incr counter</span><br><span class="line">incrby counter 10 <span class="comment">#指定增加步长</span></span><br><span class="line"><span class="comment">#为了减少延迟，可以批量设置值以及读取</span></span><br><span class="line">mset a 10 b 20 c 30</span><br><span class="line">mget a b c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有些命令不是针对特定类型的才能使用，他能与任何类型的键来配合使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">set</span> mykey hello</span><br><span class="line"><span class="comment">#检测键是否存在</span></span><br><span class="line">exists mykey</span><br><span class="line"><span class="comment">#删除键</span></span><br><span class="line">del mykey</span><br><span class="line"><span class="comment">#获取键类型</span></span><br><span class="line"><span class="built_in">type</span> mykey</span><br><span class="line"><span class="comment">#设置键值并加上过期时间</span></span><br><span class="line"><span class="built_in">set</span> key 100 ex 10</span><br><span class="line"><span class="comment">#查询过期时间</span></span><br><span class="line">ttl key</span><br></pre></td></tr></table></figure>

<p>过期时间：<br>过期时间的粒度为毫秒级，过期的时间会被复制保存到磁盘上，当服务器宕机<br>锁续命：</p>
<ul>
<li></li>
</ul>
<p>锁 key 丢失：</p>
<ul>
<li>写脚本恢复</li>
<li>Redlock</li>
</ul>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><blockquote>
<p>redis 中的 list 是通过双向循环链表（quickList）实现的，为什么链表以及这样做的好处是，</p>
<ol>
<li>双端链表，获取前后节点复杂度为 O(1)</li>
<li>无环，对链表的访问以 null 为终点</li>
<li>带头和尾节点，获取头尾节点的时间复杂度为 O(1)</li>
<li>链表计数器，对访问链表大小的时间复杂度为 O(1)</li>
</ol>
</blockquote>
<p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。提高了新增和删除的效率,但是遍历效率相对较低</p>
<blockquote>
<p>数组和链表区别：<br>结构上:</p>
<ul>
<li>数组必须先定义好固定的长度（元素个数），不能适应数据的动态增减功能。</li>
<li>链表动态的进行存储分配，可以适应数据动态增减情况，方便插入、删除数据。</li>
</ul>
<p>内存存储：</p>
<ul>
<li>（静态从栈中分配空间），快速但自由度小。</li>
<li>数组在内存中是按顺序存储的，链表是随机的。</li>
<li>数组按下标索引访问，速度比较快，但插入元素的话就得移动很多元素，所以数组插入效率低。</li>
<li>链表从堆中分配空间，自由但申请麻烦</li>
<li>链表获取长度比较快</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/25799318/1668650580784-592a03db-aaed-4591-b3d6-f6e0239148a6.png#averageHue=%23f4f4ea&clientId=u5b5872ff-fa81-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=209&id=u2f28c36c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=1030&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=172081&status=done&style=none&taskId=u2c56e547-0398-4d6f-afad-1d61554e11c&title=&width=515" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpush mylist A</span><br><span class="line">lrange mylist 0 -1</span><br><span class="line"><span class="comment">#多个变量</span></span><br><span class="line">rpush mylist 1 2 3 4 5 <span class="string">&quot;foo bar&quot;</span></span><br><span class="line">rpop mylist</span><br><span class="line"><span class="comment">#使用ltrim保持指定范围，丢弃掉后边的内容</span></span><br><span class="line">ltrim mylist 0 2</span><br><span class="line"><span class="comment">#传统的使用队列，会出现 CPU 空转问题，redis 使用阻塞方式解决这个问题</span></span><br><span class="line"><span class="comment">#使用阻塞到达指定时间没有获取到值，返回nil</span></span><br><span class="line">brpop tasks 5</span><br><span class="line">brpop tasks 0 <span class="comment">#如果设为 0 就是永远等待元素直至出现</span></span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ul>
<li>如发布我的动态。</li>
<li>消息队列</li>
</ul>
<h3 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933?fromModule=lemma_inlink">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fromModule=lemma_inlink">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288?fromModule=lemma_inlink">散列函数</a>，存放记录的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097?fromModule=lemma_inlink">数组</a>叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933?fromModule=lemma_inlink">散列表</a>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>类型是一个 string 类型的 field 和 value 的映射表，每个 hash 可以存储 232 - 1 键值对（40 多亿），hash 对存放的 key 和 val 数量没有限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hset user:1000 username antirez birthyear 1977 verified 1</span><br><span class="line"><span class="comment">#获取</span></span><br><span class="line">hget user:1000 username</span><br><span class="line">hgetall user:1000</span><br><span class="line"><span class="comment">#获取多个字段</span></span><br><span class="line">hmget user:1000 username birthyear no-such-field</span><br><span class="line"><span class="comment">#使用 hincrby 可以在 hash 中递增</span></span><br><span class="line">hincrby user:1000 birthyear 10</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ul>
<li>购物车（以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的 3 个要素）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/25799318/1668655469782-1933c4f4-dcb7-47e5-8ee8-dae48fe7680f.png#averageHue=%23efeeee&clientId=u5b5872ff-fa81-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=288&id=u7a1276a3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1266&originWidth=1122&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=331157&status=done&style=none&taskId=u741b52b4-9a5b-4ede-a4d9-db2b478201c&title=&width=255" alt="image.png"></li>
<li>存储对象</li>
</ul>
<h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p>redis set 是无序结合，可以执行交集、并集、差集计算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向集合添加元素</span></span><br><span class="line">sadd myset 1 2 3</span><br><span class="line"><span class="comment">#查看集合成员</span></span><br><span class="line">smembers myset</span><br><span class="line"><span class="comment">#检查元素是否存在集合</span></span><br><span class="line">sismember myset 3</span><br><span class="line"></span><br><span class="line">sadd news:1000:tags 1 2 5 77</span><br><span class="line"><span class="comment">#计算交集</span></span><br><span class="line">sinter tag:1:news tag:2:news</span><br><span class="line"><span class="comment">#将一个集合复制到另一个集合</span></span><br><span class="line">sunionstore game:1:deck deck</span><br><span class="line"><span class="comment">#随机剔除一个值</span></span><br><span class="line">spop game:1:deck</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取随机元素不从集合中删除</span></span><br><span class="line">SRANDMEMBER deck 4</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ul>
<li>给文章设置标签</li>
<li>好友关系</li>
<li>限流</li>
</ul>
<h3 id="Sorted-sets"><a href="#Sorted-sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h3><blockquote>
<p>sorted set 是 hash 和 set 的混合，如果两个元素 score 相同，那么根据字符排序。分说是从大到小排序。</p>
</blockquote>
<p><strong>如何实现的？</strong><br>实现注意:排序集是通过一个双端口数据结构实现的，它包含一个跳跃列表和一个哈希表，所以每次我们添加一个元素时，Redis 都会执行一个 O(log(N))操作。这很好，但是当我们请求排序的元素时，Redis 根本不需要做任何工作，它已经全部排序了:</p>
<p>跳跃表：增加了向前指针的链表叫作跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/25799318/1668733613457-cbd262a7-e7d8-4725-bebd-7644d491655a.png#averageHue=%23f6f5f5&clientId=u3fa3eca6-4a5d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=171&id=u96f05e51&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=1161&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=25936&status=done&style=none&taskId=u39d23fe6-f5f6-4f46-b342-d7f927b699c&title=&width=580.5" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置值</span></span><br><span class="line">zadd hackers 1940 <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="comment">#获取排名</span></span><br><span class="line">zrange hackers 0 -1</span><br><span class="line"><span class="comment">#按照相反的顺序排列</span></span><br><span class="line">zrevrange hackers 0 -1</span><br><span class="line"><span class="comment">#携带分数返回</span></span><br><span class="line">zrevrange hackers 0 -1 withscores</span><br><span class="line"><span class="comment">#通过 score 来过滤</span></span><br><span class="line">zrangebyscore hackers min max</span><br><span class="line">zrangebyscore hackers -inf 1950</span><br><span class="line"><span class="comment">#通过 score 删除元素</span></span><br><span class="line">zremrangebyscore hackers 1940 1960</span><br><span class="line"><span class="comment">#获取 rank 排名</span></span><br><span class="line">zrank hackers <span class="string">&#x27;王五&#x27;</span></span><br><span class="line"><span class="comment">#反序获取 rank 排名</span></span><br><span class="line">zrevrank hackers <span class="string">&#x27;王五&#x27;</span></span><br><span class="line"></span><br><span class="line">zadd hackers 0 <span class="string">&quot;Alan Kay&quot;</span> 0 <span class="string">&quot;Sophie Wilson&quot;</span> 0 <span class="string">&quot;Richard Stallman&quot;</span> 0 <span class="string">&quot;Anita Borg&quot;</span> 0 <span class="string">&quot;Yukihiro Matsumoto&quot;</span> 0 <span class="string">&quot;Hedy Lamarr&quot;</span> 0 <span class="string">&quot;Claude Shannon&quot;</span>0 <span class="string">&quot;Linus Torvalds&quot;</span> 0 <span class="string">&quot;Alan Turing&quot;</span></span><br><span class="line"><span class="comment">#在 2.8 版本以后可以通过字典顺序获取范围</span></span><br><span class="line">zrangebylex hackers [B [P</span><br><span class="line"><span class="comment">#统计数量</span></span><br><span class="line">zcard hackers</span><br></pre></td></tr></table></figure>

<p>补充说明<br>排序集的分数可以随时更新。只需对已包含在排序集中的元素调用 ZADD，就会以 O(log(N))时间复杂度更新其分数(和位置)。因此，排序集适用于有大量更新的情况。 由于这个特点，一个常见的用例就是排行榜。典型的应用程序是 Facebook 游戏，在该游戏中，您结合了根据用户的高分进行排序的功能，以及获取排名操作，以便显示排名前 n 的用户和排名后的用户</p>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><blockquote>
<p>位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作。因为字符串是二进制安全 blob，它们的最大长度是 512 MB，所以它们适合设置 2^32 个不同的位。 位操作分为两组:固定时间的单位操作，如将位设置为 1 或 0，或获取其值，以及对位组的操作，如计算给定位范围内的集合位的数量(例如，总体计数)。 位图的最大优点之一是，在存储信息时，它们通常可以节省极大的空间</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit key 10 1 <span class="comment">#setbit key offset value</span></span><br><span class="line">getbit key 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SETBIT 命令的第一个参数是位号，第二个参数是要设置位的值，即 1 或 0。如果寻址位在当前字符串长度之外，该命令将自动放大字符串。<br>GETBIT 只返回指定索引处的位的值。超出范围的位(寻址存储在目标键中的字符串长度以外的位)总是被认为是零。</p>
<ul>
<li>bittop 提供按位操作，and、or、xor、not</li>
<li>bitcount 整体统计</li>
<li>bitpos 获取指定 position 的 value</li>
</ul>
<p><strong>应用：</strong></p>
<ul>
<li><strong>实时统计（如签到）</strong></li>
<li>存储空间高效但高性能的布尔值信息与对象 id 相关联。</li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><blockquote>
<p>HyperLogLog 是一种概率数据结构，用于计数唯一的东西(技术上这指的是估计集合的基数)。通常计数唯一项需要使用与您想要计数的项数量成比例的内存，因为您需要记住过去已经见过的元素，以避免多次计数。然而，有一组算法是用内存来换取精度的:你以一个标准误差的估计度量结束，在 Redis 实现的情况下，这个标准误差小于 1%。<br>hyperLoglog 不会存储每个元素的值，通过存储 hash 元素的一个 1 的位置，来计算数量。<br>HyperLogLog 的优点在于，输入元素的数量或者体积非常大时，基数计算的存储空间是固定的<br>HyperLogLog 的算法设计能使用 12k 的内存来近似的统计 2^64 个数据</p>
</blockquote>
<p>对比 set 做 uv</p>
<ul>
<li>如果 uv 上限很高，那么 set 的空间开销就很大。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pfadd uv <span class="string">&#x27;127.0.0.1&#x27;</span> <span class="string">&#x27;127.0.0.1&#x27;</span> <span class="string">&#x27;192.168.1.1&#x27;</span></span><br><span class="line">pfcount uv</span><br><span class="line"><span class="comment">#合并</span></span><br><span class="line">pfmerge uv1 uv2</span><br></pre></td></tr></table></figure>

<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><blockquote>
<p>Redis 流是一种类似于仅追加日志的数据结构。您可以使用流实时记录并同时联合事件。<br>Redis 流用例的例子包括: 事件来源(例如，跟踪用户操作、点击等) 传感器监测(例如，现场设备的读数)<br>通知(例如，在单独的流中存储每个用户的通知记录) Redis 为每个流条目生成一个唯一的 ID。您可以使用这些 id 稍后检索它们相关联的条目，或者读取和处理流中的所有后续条目。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新增</span></span><br><span class="line">xadd event:user:20221020 *  view_page 10s</span><br><span class="line"><span class="comment">#再次新增（链式结构）</span></span><br><span class="line">xadd event:user:20221020 *  click-ad banner</span><br><span class="line"><span class="comment">#获取长度</span></span><br><span class="line">xlen event:user:20221020</span><br><span class="line"><span class="comment">#裁剪</span></span><br><span class="line">xtrim event:user:20201020 maxlen 1</span><br><span class="line"><span class="comment">#获取条目   - 的含义表示一个最小的id, + 号则表示一个最大的id</span></span><br><span class="line">xrange event:user:20221020 - +</span><br><span class="line"><span class="comment">#如果特别多使用 count 约束</span></span><br><span class="line">xrange event:user:20221020 - + count 1</span><br><span class="line"><span class="comment">#反序查找</span></span><br><span class="line">xrevrange event:user:20221020 + -</span><br><span class="line"><span class="comment">#只查询最新消息</span></span><br><span class="line"><span class="comment">#XREAD 用来监听到达 stream 的消息.</span></span><br><span class="line"><span class="comment">#count 是一个非强制选项,用来约束一次读取的条目数目.</span></span><br><span class="line"><span class="comment">#streams 是一个强制选项,用来指定读取的 stream . 0 表示只获取比指定 id 0 大的条目.</span></span><br><span class="line">xread count 1 streams event:user:20221020 0</span><br></pre></td></tr></table></figure>

<h2 id="RDB-和-AOF"><a href="#RDB-和-AOF" class="headerlink" title="RDB 和 AOF"></a>RDB 和 AOF</h2><p>RDB 和 AOF<br>RDB（reids database）<br>AOF（append on file）</p>
<p>RDB：指定时间间隔内将内存数据集快照写入磁盘中，实际操作就是 fork 一个子进程，将数据集写入临时文件，写入成功后再替换原来的文件，用二进制压缩存储。<br><strong>优点：</strong></p>
<ol>
<li>整个 redis 数据库只包含一个 dump.rdb,方便持久化</li>
<li>容灾性好，方便备份</li>
<li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以 IO 最大化。使用单独子进程进行持久化，主进程不会进行任何 IO 操作，保证 redis 高性能。</li>
<li>数据集大时比 AOF 启动效率更高。</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>数据安全性低。</li>
<li>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此当数据集非常大时，可能导致服务停止几百毫秒，甚至 1s</li>
</ul>
<p>AOF：<br>以日志形式记录服务器每一个写、删除操作，以文本方式记录，可以打开文件查看详细的操作记录。<br><strong>优点：</strong></p>
<ul>
<li><strong>数据安全，redis 提供了三种同步策略：1）每秒同步 2）每修改同步 3）不同步</strong></li>
<li><strong>容易解决数据一致性问题，可以通过 redis-check-aof 工具解决数据一致性问题</strong></li>
<li><strong>节省空间，写模式定期对 AOF 文件进行重写，已达到压缩目的</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>AOF 比 RDB 文件大，且恢复速度慢</li>
<li>数据集大时比 RDB 启动效率低</li>
<li>运行效率没有 RDB 高</li>
</ul>
<h2 id="Redis-单线程为什么这么快"><a href="#Redis-单线程为什么这么快" class="headerlink" title="Redis 单线程为什么这么快"></a>Redis 单线程为什么这么快</h2><p>原因：</p>
<ul>
<li>首先 redis 是基于内存的，所以操作非常快，多线程会出现线程切换问题，多线程切换会出现上下文切换，切换时会消耗 CPU</li>
<li>多路 IO 复用，reids 基于 Reactor 模式开发了网络时间处理器，文件事件处理器 file event handle，他是单线程的所以 redis 才叫单线程，一个线程同时监听多个 socket，文件事务处理器包含（多个 socket 、IO 复用程序、文件事件分派器、事件处理器）</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">walker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/06/redis8%20%E7%B1%BB%E5%9E%8B/">http://example.com/2022/05/06/redis8%20%E7%B1%BB%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">walker</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/05/07/Redis%20%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 缓存问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/07/Redis%20%E4%B8%BB%E4%BB%8E/" title="Redis 主从"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-07</div><div class="title">Redis 主从</div></div></a></div><div><a href="/2022/05/07/Redis%20%E5%88%86%E5%8C%BA/" title="Redis 分区"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-07</div><div class="title">Redis 分区</div></div></a></div><div><a href="/2022/05/09/Redis%20%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/" title="Redis 扩展功能"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="title">Redis 扩展功能</div></div></a></div><div><a href="/2022/05/07/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96/" title="Redis 持久化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-07</div><div class="title">Redis 持久化</div></div></a></div><div><a href="/2022/05/07/Redis%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="Redis 数据类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-07</div><div class="title">Redis 数据类型</div></div></a></div><div><a href="/2022/11/21/Redis%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="Redis 消息队列"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-21</div><div class="title">Redis 消息队列</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdwx.qlogo.cn/mmopen/vi_32/BsLUROthXHzaLGgAuYiapwa4htsNc0H2MQ8sGkVHVNqib7viaqwhXK6KDXayjQBpkPY0gleTCqAcEPL1kEwjP9S0Q/132" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">walker</div><div class="author-info__description">学如逆水行舟不进则退</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lvyasen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:18530893662@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">redis 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">1.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lists"><span class="toc-number">1.2.</span> <span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashes"><span class="toc-number">1.3.</span> <span class="toc-text">Hashes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sets"><span class="toc-number">1.4.</span> <span class="toc-text">Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-sets"><span class="toc-number">1.5.</span> <span class="toc-text">Sorted sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps"><span class="toc-number">1.6.</span> <span class="toc-text">Bitmaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">1.7.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream"><span class="toc-number">1.8.</span> <span class="toc-text">Stream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-%E5%92%8C-AOF"><span class="toc-number">2.</span> <span class="toc-text">RDB 和 AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">3.</span> <span class="toc-text">Redis 单线程为什么这么快</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/02/%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="常用解决方案">常用解决方案</a><time datetime="2023-01-02T09:32:58.000Z" title="发表于 2023-01-02 17:32:58">2023-01-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/02/Go%20ORM/" title="Go ORM">Go ORM</a><time datetime="2023-01-02T05:10:25.000Z" title="发表于 2023-01-02 13:10:25">2023-01-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/31/Kubernetes%20%E9%83%A8%E7%BD%B2/" title="Kubernetes 部署">Kubernetes 部署</a><time datetime="2022-12-31T06:27:06.000Z" title="发表于 2022-12-31 14:27:06">2022-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/31/Kubernetes%20%E5%AE%89%E8%A3%85/" title="Kubernetes 安装">Kubernetes 安装</a><time datetime="2022-12-31T06:01:53.000Z" title="发表于 2022-12-31 14:01:53">2022-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/31/Kubernetes%20%E7%AE%80%E4%BB%8B/" title="Kubernetes 简介">Kubernetes 简介</a><time datetime="2022-12-31T05:51:00.000Z" title="发表于 2022-12-31 13:51:00">2022-12-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By walker</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>